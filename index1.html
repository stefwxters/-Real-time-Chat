<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>P2P File Share</title>
  <meta name="description" content="Fast, secure peer-to-peer file sharing">
  <!-- Critical CSS inlined for PageSpeed -->
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; background: #f0f0f0; color: #333; }
    .container { max-width: 600px; text-align: center; padding: 20px; }
    h1 { font-size: 24px; margin-bottom: 20px; }
    #dropZone { border: 2px dashed #ccc; padding: 40px; cursor: pointer; transition: border-color 0.3s; }
    #dropZone:hover, #dropZone.dragover { border-color: #007bff; }
    #fileInput { display: none; }
    #linkOutput { margin-top: 20px; padding: 10px; background: #fff; border: 1px solid #ddd; word-break: break-all; }
    #downloadSection { margin-top: 20px; }
    button { padding: 10px 20px; background: #007bff; color: #fff; border: none; cursor: pointer; font-size: 16px; margin-top: 10px; }
    button:hover { background: #0056b3; }
    p { margin: 10px 0; }
  </style>
</head>
<body>
  <div class="container">
    <h1>P2P File Share</h1>
    <div id="dropZone">Drag & drop a file here or click to select</div>
    <input type="file" id="fileInput">
    <p id="status">Select a file to share</p>
    <div id="linkOutput" style="display: none;"></div>
    <div id="downloadSection" style="display: none;">
      <p>Downloading...</p>
      <button id="saveFile">Save File</button>
    </div>
  </div>

  <script>
    // WebRTC and file handling logic
    let peerConnection = null;
    let dataChannel = null;
    let file = null;
    let fileReader = new FileReader();
    let receivedBuffers = [];
    let fileName = '';
    let fileSize = 0;

    // Mock signaling server (in production, use WebSocket or service)
    const mockSignaling = {
      generateId: () => Math.random().toString(36).substring(2, 10),
      sendOffer: (id, offer) => localStorage.setItem(id, JSON.stringify(offer)),
      getOffer: (id) => JSON.parse(localStorage.getItem(id) || null),
      sendAnswer: (id, answer) => localStorage.setItem(id + '_answer', JSON.stringify(answer)),
      getAnswer: (id) => JSON.parse(localStorage.getItem(id + '_answer') || null)
    };

    // Initialize WebRTC
    function initPeerConnection() {
      peerConnection = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      });

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          // In production, send candidate via signaling server
        }
      };

      dataChannel = peerConnection.createDataChannel('fileTransfer');
      dataChannel.onopen = () => console.log('Data channel open');
      dataChannel.onmessage = handleMessage;
    }

    // Handle incoming messages (file chunks)
    function handleMessage(event) {
      if (typeof event.data === 'string') {
        const metadata = JSON.parse(event.data);
        fileName = metadata.name;
        fileSize = metadata.size;
        document.getElementById('status').textContent = `Receiving ${fileName} (${(fileSize / 1024 / 1024).toFixed(2)} MB)`;
      } else {
        receivedBuffers.push(event.data);
        if (receivedBuffers.reduce((sum, buf) => sum + buf.size, 0) >= fileSize) {
          document.getElementById('saveFile').style.display = 'block';
        }
      }
    }

    // File selection and drag-and-drop
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const status = document.getElementById('status');
    const linkOutput = document.getElementById('linkOutput');

    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('dragover');
    });
    dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('dragover');
      file = e.dataTransfer.files[0];
      handleFile(file);
    });
    fileInput.addEventListener('change', () => {
      file = fileInput.files[0];
      handleFile(file);
    });

    // Handle file upload and generate shareable link
    async function handleFile(file) {
      if (!file) return;
      status.textContent = `Selected ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
      initPeerConnection();

      // Create offer
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);

      // Mock signaling: Store offer
      const shareId = mockSignaling.generateId();
      mockSignaling.sendOffer(shareId, offer);

      // Generate shareable URL
      const shareUrl = `${window.location.origin}/?shareId=${shareId}`;
      linkOutput.textContent = shareUrl;
      linkOutput.style.display = 'block';

      // Send file when channel is open
      dataChannel.onopen = () => {
        fileReader.onload = () => {
          const arrayBuffer = fileReader.result;
          const chunkSize = 16384;
          const metadata = { name: file.name, size: file.size };
          dataChannel.send(JSON.stringify(metadata));
          for (let i = 0; i < arrayBuffer.byteLength; i += chunkSize) {
            dataChannel.send(arrayBuffer.slice(i, i + chunkSize));
          }
        };
        fileReader.readAsArrayBuffer(file);
      };

      // Check for answer
      const checkAnswer = setInterval(async () => {
        const answer = mockSignaling.getAnswer(shareId);
        if (answer) {
          await peerConnection.setRemoteDescription(answer);
          clearInterval(checkAnswer);
        }
      }, 1000);
    }

    // Handle download (recipient side)
    async function handleDownload(shareId) {
      document.getElementById('dropZone').style.display = 'none';
      document.getElementById('downloadSection').style.display = 'block';
      initPeerConnection();

      // Get offer from signaling
      const offer = mockSignaling.getOffer(shareId);
      if (!offer) {
        status.textContent = 'Invalid or expired share link';
        return;
      }

      await peerConnection.setRemoteDescription(offer);
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);
      mockSignaling.sendAnswer(shareId, answer);

      // Handle file save
      document.getElementById('saveFile').addEventListener('click', () => {
        const blob = new Blob(receivedBuffers);
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(url);
      });
    }

    // Check URL for shareId (recipient)
    const urlParams = new URLSearchParams(window.location.search);
    const shareId = urlParams.get('shareId');
    if (shareId) handleDownload(shareId);
  </script>
</body>
</html>
