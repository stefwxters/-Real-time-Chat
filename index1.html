<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>P2P File Share</title>
  <meta name="description" content="Fast, secure peer-to-peer file sharing">
  <!-- Critical CSS inlined for PageSpeed -->
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; background: #f0f0f0; color: #333; }
    .container { max-width: 600px; text-align: center; padding: 20px; }
    h1 { font-size: 24px; margin-bottom: 20px; }
    #dropZone { border: 2px dashed #ccc; padding: 40px; cursor: pointer; transition: border-color 0.3s; }
    #dropZone:hover, #dropZone.dragover { border-color: #007bff; }
    #fileInput { display: none; }
    #linkOutput { margin-top: 20px; padding: 10px; background: #fff; border: 1px solid #ddd; word-break: break-all; }
    #downloadSection { margin-top: 20px; }
    #answerInput { margin-top: 20px; width: 100%; padding: 10px; }
    button { padding: 10px 20px; background: #007bff; color: #fff; border: none; cursor: pointer; font-size: 16px; margin-top: 10px; }
    button:hover { background: #0056b3; }
    p { margin: 10px 0; }
    textarea { width: 100%; height: 100px; margin-top: 10px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>P2P File Share</h1>
    <div id="dropZone">Drag & drop a file here or click to select</div>
    <input type="file" id="fileInput">
    <p id="status">Select a file to share</p>
    <div id="linkOutput" style="display: none;"></div>
    <textarea id="offerOutput" placeholder="Offer will appear here (share with recipient)" style="display: none;"></textarea>
    <div id="answerSection" style="display: none;">
      <p>Paste the answer from the recipient here:</p>
      <textarea id="answerInput" placeholder="Paste answer here"></textarea>
      <button id="submitAnswer">Submit Answer</button>
    </div>
    <div id="downloadSection" style="display: none;">
      <p>Downloading...</p>
      <textarea id="answerOutput" placeholder="Answer will appear here (share with uploader)" style="display: none;"></textarea>
      <button id="saveFile">Save File</button>
    </div>
  </div>

  <script>
    // Configuration: Set your base URL here
    const BASE_URL = 'https://stefwxters.github.io/Real-time-Chat'; // Replace with your hosting URL, e.g., https://yourdomain.com

    // WebRTC and file handling logic
    let peerConnection = null;
    let dataChannel = null;
    let file = null;
    let fileReader = new FileReader();
    let receivedBuffers = [];
    let fileName = '';
    let fileSize = 0;

    // Mock signaling for same-device testing (replace with manual exchange in production)
    const mockSignaling = {
      generateId: () => Math.random().toString(36).substring(2, 10),
      storeOffer: (id, offer) => localStorage.setItem(id, JSON.stringify(offer)),
      getOffer: (id) => JSON.parse(localStorage.getItem(id) || null),
      storeAnswer: (id, answer) => localStorage.setItem(id + '_answer', JSON.stringify(answer)),
      getAnswer: (id) => JSON.parse(localStorage.getItem(id + '_answer') || null)
    };

    // Initialize WebRTC
    function initPeerConnection(isUploader) {
      peerConnection = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      });

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          // In production, candidates are included in offer/answer
        }
      };

      if (isUploader) {
        dataChannel = peerConnection.createDataChannel('fileTransfer');
        dataChannel.onopen = () => console.log('Data channel open');
        dataChannel.onmessage = handleMessage;
      } else {
        peerConnection.ondatachannel = (event) => {
          dataChannel = event.channel;
          dataChannel.onmessage = handleMessage;
        };
      }
    }

    // Handle incoming messages (file chunks)
    function handleMessage(event) {
      if (typeof event.data === 'string') {
        const metadata = JSON.parse(event.data);
        fileName = metadata.name;
        fileSize = metadata.size;
        document.getElementById('status').textContent = `Receiving ${fileName} (${(fileSize / 1024 / 1024).toFixed(2)} MB)`;
      } else {
        receivedBuffers.push(event.data);
        if (receivedBuffers.reduce((sum, buf) => sum + buf.size, 0) >= fileSize) {
          document.getElementById('saveFile').style.display = 'block';
        }
      }
    }

    // File selection and drag-and-drop
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const status = document.getElementById('status');
    const linkOutput = document.getElementById('linkOutput');
    const offerOutput = document.getElementById('offerOutput');
    const answerInput = document.getElementById('answerInput');
    const answerSection = document.getElementById('answerSection');
    const submitAnswer = document.getElementById('submitAnswer');

    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('dragover');
    });
    dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('dragover');
      file = e.dataTransfer.files[0];
      handleFile(file);
    });
    fileInput.addEventListener('change', () => {
      file = fileInput.files[0];
      handleFile(file);
    });

    // Handle file upload and generate shareable link
    async function handleFile(file) {
      if (!file) return;
      status.textContent = `Selected ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
      initPeerConnection(true);

      // Generate unique share ID
      const shareId = mockSignaling.generateId();

      // Create offer
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);

      // Store offer for same-device testing
      mockSignaling.storeOffer(shareId, offer);

      // Generate shareable URL
      const shareUrl = `${BASE_URL}/?shareId=${shareId}`;
      linkOutput.textContent = shareUrl;
      linkOutput.style.display = 'block';

      // Show offer for manual signaling
      offerOutput.value = JSON.stringify(offer);
      offerOutput.style.display = 'block';
      answerSection.style.display = 'block';

      // Send file when channel is open
      dataChannel.onopen = () => {
        fileReader.onload = () => {
          const arrayBuffer = fileReader.result;
          const chunkSize = 16384;
          const metadata = { name: file.name, size: file.size };
          dataChannel.send(JSON.stringify(metadata));
          for (let i = 0; i < arrayBuffer.byteLength; i += chunkSize) {
            dataChannel.send(arrayBuffer.slice(i, i + chunkSize));
          }
        };
        fileReader.readAsArrayBuffer(file);
      };

      // Check for answer (manual or mock)
      submitAnswer.addEventListener('click', async () => {
        const answerText = answerInput.value.trim();
        if (answerText) {
          const answer = JSON.parse(answerText);
          await peerConnection.setRemoteDescription(answer);
          status.textContent = 'Connected! Transferring file...';
        }
      });

      // Poll for answer in same-device testing
      const checkAnswer = setInterval(async () => {
        const answer = mockSignaling.getAnswer(shareId);
        if (answer) {
          await peerConnection.setRemoteDescription(answer);
          clearInterval(checkAnswer);
        }
      }, 1000);
    }

    // Handle download (recipient side)
    async function handleDownload(shareId) {
      document.getElementById('dropZone').style.display = 'none';
      document.getElementById('downloadSection').style.display = 'block';
      initPeerConnection(false);

      // Get offer (manual or mock)
      const offer = mockSignaling.getOffer(shareId);
      if (!offer) {
        status.textContent = 'Waiting for offer... Paste the offer below:';
        const offerInput = document.createElement('textarea');
        offerInput.placeholder = 'Paste offer here';
        offerInput.style.width = '100%';
        offerInput.style.height = '100px';
        offerInput.style.marginTop = '10px';
        const submitOffer = document.createElement('button');
        submitOffer.textContent = 'Submit Offer';
        submitOffer.style.marginTop = '10px';
        document.getElementById('downloadSection').prepend(submitOffer, offerInput);

        submitOffer.addEventListener('click', async () => {
          const offerText = offerInput.value.trim();
          if (offerText) {
            const offer = JSON.parse(offerText);
            await peerConnection.setRemoteDescription(offer);
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            document.getElementById('answerOutput').value = JSON.stringify(answer);
            document.getElementById('answerOutput').style.display = 'block';
            status.textContent = 'Answer generated. Share it with the uploader.';
            mockSignaling.storeAnswer(shareId, answer); // For same-device testing
          }
        });
        return;
      }

      await peerConnection.setRemoteDescription(offer);
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);
      document.getElementById('answerOutput').value = JSON.stringify(answer);
      document.getElementById('answerOutput').style.display = 'block';
      status.textContent = 'Answer generated. Share it with the uploader.';
      mockSignaling.storeAnswer(shareId, answer); // For same-device testing

      // Handle file save
      document.getElementById('saveFile').addEventListener('click', () => {
        const blob = new Blob(receivedBuffers);
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(url);
      });
    }

    // Check URL for shareId (recipient)
    const urlParams = new URLSearchParams(window.location.search);
    const shareId = urlParams.get('shareId');
    if (shareId) handleDownload(shareId);
  </script>
</body>
</html>
