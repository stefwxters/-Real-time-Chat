<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>P2P File Share</title>
  <meta name="description" content="Fast, secure peer-to-peer file sharing">
  <!-- Critical CSS inlined for PageSpeed -->
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; background: #f0f0f0; color: #333; }
    .container { max-width: 600px; text-align: center; padding: 20px; }
    h1 { font-size: 24px; margin-bottom: 20px; }
    #dropZone { border: 2px dashed #ccc; padding: 40px; cursor: pointer; transition: border-color 0.3s; }
    #dropZone:hover, #dropZone.dragover { border-color: #007bff; }
    #fileInput { display: none; }
    #linkOutput { margin-top: 20px; padding: 10px; background: #fff; border: 1px solid #ddd; word-break: break-all; }
    #downloadSection { margin-top: 20px; }
    button { padding: 10px 20px; background: #007bff; color: #fff; border: none; cursor: pointer; font-size: 16px; margin-top: 10px; }
    button:hover { background: #0056b3; }
    p { margin: 10px 0; }
    input[type="text"] { padding: 10px; width: 200px; margin-top: 10px; }
  </style>
  <!-- PeerJS (minified, included inline for PageSpeed) -->
  <script>
    // Minified PeerJS (subset for brevity, use full minified version from https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js)
    !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.Peer=t()}(this,function(){var e=function(){function e(t){var n=this;this.id=null,this.debug=!1,this.disconnected=!1,this._lastServerId=null,this._open=!1,this._connections=new Map,this._lostMessages={},t&&t.key&&(this.key=t.key),t&&t.host&&(this.host=t.host),t&&t.port&&(this.port=t.port),t&&t.path&&(this.path=t.path),this.secure=t&&t.secure||!1,this._initialize()}return e.prototype._initialize=function(){var e=this,t=this.host+this.path+(this.port?":"+this.port:""),n=new WebSocket((this.secure?"wss://":"ws://")+t);this.socket=n,n.onmessage=function(t){var r;try{r=JSON.parse(t.data)}catch(e){return void console.error("Invalid server message",t.data)}e._handleMessage(r)},n.onclose=function(){e.disconnected||(e.disconnected=!0,e._open=!1,e.emit("disconnected",e.id),e.emit("close"))},n.onopen=function(){e._open=!0,e._register()}},e.prototype._register=function(){var e=this;this.socket.send(JSON.stringify({type:"OPEN",key:this.key})),this.socket.send(JSON.stringify({type:"ID",id:this._lastServerId}))},e.prototype._handleMessage=function(e){switch(e.type){case"ID":this.id=e.id,this._lastServerId=this.id,this.emit("open",this.id);break;case"OPEN":this.emit("open",this.id);break;case"ERROR":this.emit("error",new Error(e.msg));break;case"PEER":var t=e.src,n=e.dst,r=this._connections.get(t);r&&r.status===WebSocket.OPEN?r.send(e.payload):this._lostMessages[t]=this._lostMessages[t]||[],this._lostMessages[t].push(e.payload);break}},e.prototype.connect=function(e,t){var n=this,r=new WebSocket(this.host+this.path+(this.port?":"+this.port:"")),i=new DataConnection(e,r,t);return this._connections.set(e,i),r.onopen=function(){i.initialize(),n._lostMessages[e]&&n._lostMessages[e].forEach(function(e){i.handleMessage({type:"PEER",payload:e})}),delete n._lostMessages[e]},i},e.prototype.call=function(e,t,n){return new MediaConnection(e,t,n)},e.prototype.close=function(){this.disconnected=!0,this._open=!1,this.socket.close(),this._connections.forEach(function(e){e.close()}),this.emit("close")},e.prototype.on=function(e,t){this._events=this._events||{},this._events[e]=this._events[e]||[],this._events[e].push(t)},e.prototype.emit=function(e){for(var t=this,n=arguments.length,r=new Array(n>1?n-1:0),i=1;i<n;i++)r[i-1]=arguments[i];this._events&&this._events[e]&&this._events[e].forEach(function(e){e.apply(t,r)})},e}(),t=function(){function e(e,t,n){this.id=e,this.socket=t,this.options=n,this.status=WebSocket.CONNECTING,this._dc=null,this._buffer=[],this._open=!1}return e.prototype.initialize=function(){var e=this;this.socket.onmessage=function(t){var n;try{n=JSON.parse(t.data)}catch(e){return void console.error("Invalid message",t.data)}e.handleMessage(n)},this.status=WebSocket.OPEN,this._open=!0,this._buffer.forEach(function(t){e.send(t)}),this._buffer=[]},e.prototype.handleMessage=function(e){switch(e.type){case"OPEN":this.emit("open");break;case"DATA":this.emit("data",e.payload);break}},e.prototype.send=function(e){this._open?this.socket.send(JSON.stringify({type:"DATA",payload:e})):this._buffer.push(e)},e.prototype.close=function(){this._open=!1,this.status=WebSocket.CLOSED,this.socket.close(),this.emit("close")},e.prototype.on=function(e,t){this._events=this._events||{},this._events[e]=this._events[e]||[],this._events[e].push(t)},e.prototype.emit=function(e){for(var t=this,n=arguments.length,r=new Array(n>1?n-1:0),i=1;i<n;i++)r[i-1]=arguments[i];this._events&&this._events[e]&&this._events[e].forEach(function(e){e.apply(t,r)})},e}();return e});
  </script>
</head>
<body>
  <div class="container">
    <h1>P2P File Share</h1>
    <div id="dropZone">Drag & drop a file here or click to select</div>
    <input type="file" id="fileInput">
    <p id="status">Select a file to share</p>
    <div id="linkOutput" style="display: none;"></div>
    <div id="downloadSection" style="display: none;">
      <p>Enter the share code:</p>
      <input type="text" id="shareCodeInput" placeholder="e.g., abc123">
      <button id="connectPeer">Connect</button>
      <p id="downloadStatus"></p>
      <button id="saveFile" style="display: none;">Save File</button>
    </div>
  </div>

  <script>
    // Configuration: Set your base URL here
    const BASE_URL = 'https://stefwxters.github.io/Real-time-Chat'; // Replace with your hosting URL, e.g., https://yourdomain.com

    // File handling logic
    let peer = null;
    let conn = null;
    let file = null;
    let fileReader = new FileReader();
    let receivedBuffers = [];
    let fileName = '';
    let fileSize = 0;

    // File selection and drag-and-drop
    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');
    const status = document.getElementById('status');
    const linkOutput = document.getElementById('linkOutput');
    const shareCodeInput = document.getElementById('shareCodeInput');
    const connectPeer = document.getElementById('connectPeer');
    const downloadStatus = document.getElementById('downloadStatus');

    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropZone.classList.add('dragover');
    });
    dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
    dropZone.addEventListener('drop', (e) => {
      e.preventDefault();
      dropZone.classList.remove('dragover');
      file = e.dataTransfer.files[0];
      handleFile(file);
    });
    fileInput.addEventListener('change', () => {
      file = fileInput.files[0];
      handleFile(file);
    });

    // Handle file upload and generate shareable link
    async function handleFile(file) {
      if (!file) return;
      status.textContent = `Selected ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;

      // Initialize PeerJS
      const shareId = Math.random().toString(36).substring(2, 10);
      peer = new Peer(shareId, { host: 'peerjs.com', port: 443, secure: true });

      peer.on('open', (id) => {
        const shareUrl = `${BASE_URL}/?shareId=${id}`;
        linkOutput.textContent = `Share code: ${id}\nURL: ${shareUrl}`;
        linkOutput.style.display = 'block';
        status.textContent = 'Waiting for recipient to connect...';
      });

      peer.on('connection', (connection) => {
        conn = connection;
        conn.on('open', () => {
          status.textContent = 'Connected! Transferring file...';
          fileReader.onload = () => {
            const arrayBuffer = fileReader.result;
            const chunkSize = 16384;
            const metadata = { name: file.name, size: file.size };
            conn.send(JSON.stringify(metadata));
            for (let i = 0; i < arrayBuffer.byteLength; i += chunkSize) {
              conn.send(arrayBuffer.slice(i, i + chunkSize));
            }
          };
          fileReader.readAsArrayBuffer(file);
        });
      });

      peer.on('error', (err) => {
        status.textContent = `Error: ${err.message}`;
      });
    }

    // Handle download (recipient side)
    async function handleDownload(shareId) {
      document.getElementById('dropZone').style.display = 'none';
      document.getElementById('downloadSection').style.display = 'block';

      connectPeer.addEventListener('click', () => {
        const peerId = shareCodeInput.value.trim();
        if (!peerId) {
          downloadStatus.textContent = 'Please enter a share code';
          return;
        }

        peer = new Peer({ host: 'peerjs.com', port: 443, secure: true });
        conn = peer.connect(peerId);

        conn.on('open', () => {
          downloadStatus.textContent = 'Connected! Waiting for file...';
        });

        conn.on('data', (data) => {
          if (typeof data === 'string') {
            const metadata = JSON.parse(data);
            fileName = metadata.name;
            fileSize = metadata.size;
            downloadStatus.textContent = `Receiving ${fileName} (${(fileSize / 1024 / 1024).toFixed(2)} MB)`;
          } else {
            receivedBuffers.push(data);
            if (receivedBuffers.reduce((sum, buf) => sum + buf.size, 0) >= fileSize) {
              document.getElementById('saveFile').style.display = 'block';
            }
          }
        });

        conn.on('error', (err) => {
          downloadStatus.textContent = `Error: ${err.message}`;
        });
      });

      // Pre-fill share code if provided in URL
      if (shareId) {
        shareCodeInput.value = shareId;
        connectPeer.click();
      }
    }

    // Handle file save
    document.getElementById('saveFile').addEventListener('click', () => {
      const blob = new Blob(receivedBuffers);
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      a.click();
      URL.revokeObjectURL(url);
    });

    // Check URL for shareId (recipient)
    const urlParams = new URLSearchParams(window.location.search);
    const shareId = urlParams.get('shareId');
    if (shareId) handleDownload(shareId);
  </script>
</body>
</html>
